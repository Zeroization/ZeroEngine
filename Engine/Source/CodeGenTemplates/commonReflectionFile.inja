// Generated by inja template engine.
// This file is used for supporting reflection, don't modify it !!
#pragma once
// Auto-generated include files:
## for include_header_file in include_header_files
#include "{{ include_header_file }}"
## endfor

namespace ZeroEngine::Reflection
{
    // Auto-generated class reflection data
## for class_def in class_defines
    // Class: {{ class_def.class_name }}
    class Type{{ class_def.class_name }}Operator
    {
    public:
        // Class
        static const char* GetClassName() { return "{{ class_def.class_name }}"; }

        // Base class
        static void GetBaseClassNameList_{{ class_def.class_name }}(std::vector<std::string>& baseClassNameList)
        {
## if class_def.class_has_base
            baseClassNameList.reserve({{ class_def.class_base_class_size }});
## for base_class_def in class_def.class_base_class_defines
            baseClassNameList.emplace_back("{{ base_class_def.class_base_class_name }}");
## endfor
## endif
        }

        // Fields
## for field_def in class_def.class_field_defines
        // Field: {{ field_def.class_field_type }} {{ field_def.class_field_name }}
        static const char* GetFieldName_{{ field_def.class_field_name }}() { return "{{ field_def.class_field_name }}"; }
        static const char* GetFieldTypeName_{{ field_def.class_field_name }}() { return "{{ field_def.class_field_type }}"; }
        static int Set_{{ field_def.class_field_name }}({{ class_def.class_name }}& type, const {{ field_def.class_field_type }}& value) { return type.{{ field_def.class_field_name }} = value; }
        static {{ field_def.class_field_type }} Get_{{ field_def.class_field_name }}(const {{ class_def.class_name }}& type) { return type.{{ field_def.class_field_name }}; }
        static bool isSequence_{{ field_def.class_field_name }}() { return {{ field_def.class_field_is_sequence }}; }
        static bool isAssociate_{{ field_def.class_field_name }}() { return {{ field_def.class_field_is_associate }}; }
## endfor

        // Methods
## for method_def in class_def.class_method_defines
        // Method: {{ method_def.class_method_return_type }} {{ method_def.class_method_name }}({% if method_def.class_method_has_args %}{% for arg in method_def.class_method_args %}{% if not loop.is_first %}, {% endif %}{{arg.arg_type}} {{arg.arg_name}}{% endfor %}{% endif %})
        // static const char* GetMethodName_{{ method_def.class_method_name }}() { return "{{ method_def.class_method_name }}"; }
## endfor

    // Register to reflection system
    static void TypeWrapperRegister_{{ class_def.class_name }}()
    {
        LOG_DEBUG(std::format("[{}] Register class: {}", __FUNCTION__, "{{ class_def.class_name }}"));

        // Register class itself
        ZERO_REFL_REGISTER_CLASS({{ class_def.class_name }});

## if class_def.class_has_base
        // Register base classes
## for class_base_class_data in class_def.class_base_class_defines
        ZERO_REFL_REGISTER_BASE_CLASS({{ class_def.class_name }}, {{ class_base_class_data.class_base_class_name }});
## endfor
## endif

        // Register class constructor
        ZERO_REFL_REGISTER_CTOR_BY_ARGS({{ class_def.class_name }});
## for class_ctor_data in class_def.class_ctor_defines
## if class_ctor_data.class_ctor_has_args
        ZERO_REFL_REGISTER_CTOR_BY_ARGS({{ class_def.class_name }}{% for arg in class_ctor_data.class_ctor_args %}, {{ arg.arg_type }}{% endfor %});
## endif
## endfor

        // Register field members and variables
## for field_def in class_def.class_field_defines
        ZERO_REFL_REGISTER_VARIABLE({{ class_def.class_name }}, {{ class_def.class_name }}::{{ field_def.class_field_name }}, &{{ class_def.class_name }}::{{ field_def.class_field_name }});
        // ZERO_REFL_REGISTER_VARIABLE_BY_GETTER_AND_SETTER({{ class_def.class_name }}, &TypeFieldReflectionOperator::Type{{ class_def.class_name }}Operator::Get_{{ field_def.class_field_name }}, &TypeFieldReflectionOperator::Type{{ class_def.class_name }}Operator::Set_{{ field_def.class_field_name }});
## endfor

        // Register function and methods
## for method_def in class_def.class_method_defines
## if method_def.class_method_has_args
        ZERO_REFL_REGISTER_FUNCTION({{ class_def.class_name }}, {{ class_def.class_name }}::{{ method_def.class_method_name }}, &{{ class_def.class_name }}::{{ method_def.class_method_name }}, {{ method_def.class_method_return_type }}{% for arg in method_def.class_method_args %}, {{arg.arg_type}}{% endfor %});
## else
        ZERO_REFL_REGISTER_FUNCTION_NO_ARGS({{ class_def.class_name }}, {{ class_def.class_name }}::{{ method_def.class_method_name }}, &{{ class_def.class_name }}::{{ method_def.class_method_name }});
## endif
## endfor
    }
## endfor
};

namespace TypeWrapperRegister
{
    // auto-generated total register
    static void Register_{{ source_file_name_upper_camel_case }}()
    {
## for class_def in class_defines
        Type{{ class_def.class_name }}Operator::TypeWrapperRegister_{{ class_def.class_name }}();
## endfor
    }
} // namespace ZeroEngine::Reflection::TypeWrapperRegister
} // namespace ZeroEngine::Reflection

// For json based serialize/deserialize
namespace nlohmann
{
## for class_def in class_defines
    template<>
    struct adl_serializer<{{ class_def.class_name }}>
    {
        static void to_json(json& ctx, const {{ class_def.class_name }}& instance)
        {
            // Register field members and variables
## for field_def in class_def.class_field_defines
            ctx["{{ field_def.class_field_name }}"] = instance.{{ field_def.class_field_name }};
## endfor
        }

        static void from_json(const json& ctx, {{ class_def.class_name }}& instance)
        {
## for field_def in class_def.class_field_defines
            instance.{{ field_def.class_field_name }} = ctx.at("{{ field_def.class_field_name }}").get<{{ field_def.class_field_type }}>();
## endfor
        }
    };
## endfor
} // namespace nlohmann
