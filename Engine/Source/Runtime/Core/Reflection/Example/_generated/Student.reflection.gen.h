// Generated by inja template engine.
// This file is used for supporting reflection, don't modify it !!
#pragma once
// Auto-generated include files:
#include "../Student.h"

namespace ZeroEngine::Reflection
{
    // Auto-generated class reflection data
    // Class: Student
    class TypeStudentOperator
    {
    public:
        // TODO: Serialization
        //        static void* CtorWithJson(const Json& jsonContext)
        //        {
        //            Student* retInstance = new Student;
        //            Serializer::Read(jsonContext, *retInstance);
        //            return retInstance;
        //        }
        //        static Json WriteByName(void* instance) { return Serializer::Write(*(Student*) instance); }

        // Class
        static const char* GetClassName() { return "Student"; }

        // Base class
        static void GetBaseClassNameList_Student(std::vector<std::string>& baseClassNameList)
        {
            baseClassNameList.reserve(1);
            baseClassNameList.emplace_back("StudentParentClass");
        }

        // Fields
        // Field: int mClassID
        static const char* GetFieldName_mClassID() { return "mClassID"; }
        static const char* GetFieldTypeName_mClassID() { return "int"; }
        static int Set_mClassID(Student& type, const int& value) { return type.mClassID = value; }
        static int Get_mClassID(const Student& type) { return type.mClassID; }
        static bool isSequence_mClassID() { return false; }
        static bool isAssociate_mClassID() { return false; }
        // Field: bool mGender
        static const char* GetFieldName_mGender() { return "mGender"; }
        static const char* GetFieldTypeName_mGender() { return "bool"; }
        static int Set_mGender(Student& type, const bool& value) { return type.mGender = value; }
        static bool Get_mGender(const Student& type) { return type.mGender; }
        static bool isSequence_mGender() { return false; }
        static bool isAssociate_mGender() { return false; }

        // Methods
        // Method: void constSetID(const int Val)
        // static const char* GetMethodName_constSetID() { return "constSetID"; }
        // Method: void pointerSetID(int * pVal)
        // static const char* GetMethodName_pointerSetID() { return "pointerSetID"; }
        // Method: void SetClassID(int Val)
        // static const char* GetMethodName_SetClassID() { return "SetClassID"; }
        // Method: void SetClassID(int Val, int inc)
        // static const char* GetMethodName_SetClassID() { return "SetClassID"; }
        // Method: void SetClassID(float Val)
        // static const char* GetMethodName_SetClassID() { return "SetClassID"; }
        // Method: void SetGender(bool val)
        // static const char* GetMethodName_SetGender() { return "SetGender"; }
        // Method: void SetClassIDAndGender(int _classID, bool _gender)
        // static const char* GetMethodName_SetClassIDAndGender() { return "SetClassIDAndGender"; }
        // Method: int GetClassID()
        // static const char* GetMethodName_GetClassID() { return "GetClassID"; }

        // Register to reflection system
        static void TypeWrapperRegister_Student()
        {
            // Register class itself
            ZERO_REFL_REGISTER_CLASS(Student);

            // Register base classes
            ZERO_REFL_REGISTER_BASE_CLASS(Student, StudentParentClass);

            // Register class constructor
            ZERO_REFL_REGISTER_CTOR_BY_ARGS(Student);
            ZERO_REFL_REGISTER_CTOR_BY_ARGS(Student, int, bool);

            // Register field members ans variables
            ZERO_REFL_REGISTER_VARIABLE(Student, mClassID, &Student::mClassID);
            // ZERO_REFL_REGISTER_VARIABLE_BY_GETTER_AND_SETTER(Student, &TypeFieldReflectionOperator::TypeStudentOperator::Get_mClassID, &TypeFieldReflectionOperator::TypeStudentOperator::Set_mClassID);
            ZERO_REFL_REGISTER_VARIABLE(Student, mGender, &Student::mGender);
            // ZERO_REFL_REGISTER_VARIABLE_BY_GETTER_AND_SETTER(Student, &TypeFieldReflectionOperator::TypeStudentOperator::Get_mGender, &TypeFieldReflectionOperator::TypeStudentOperator::Set_mGender);

            // Register function and methods
            ZERO_REFL_REGISTER_FUNCTION_NO_ARGS(Student, Student::staticTest, &Student::staticTest);
            ZERO_REFL_REGISTER_FUNCTION(Student, Student::constSetID, &Student::constSetID, void, const int);
            ZERO_REFL_REGISTER_FUNCTION(Student, Student::pointerSetID, &Student::pointerSetID, void, int *);
            ZERO_REFL_REGISTER_FUNCTION(Student, Student::SetClassID, &Student::SetClassID, void, int);
            ZERO_REFL_REGISTER_FUNCTION(Student, Student::SetClassID, &Student::SetClassID, void, int, int);
            ZERO_REFL_REGISTER_FUNCTION(Student, Student::SetClassID, &Student::SetClassID, void, float);
            ZERO_REFL_REGISTER_FUNCTION(Student, Student::SetGender, &Student::SetGender, void, bool);
            ZERO_REFL_REGISTER_FUNCTION(Student, Student::SetClassIDAndGender, &Student::SetClassIDAndGender, void, int,
                                        bool);
            ZERO_REFL_REGISTER_FUNCTION_NO_ARGS(Student, Student::GetClassID, &Student::GetClassID);
        }
    };

    namespace TypeWrapperRegister
    {
        // auto-generated total register
        void Register_Student()
        {
            TypeStudentOperator::TypeWrapperRegister_Student();
        }
    } // namespace ZeroEngine::Reflection::TypeWrapperRegister
} // namespace ZeroEngine::Reflection

namespace nlohmann
{
    template<>
    struct adl_serializer<Student>
    {
        static void to_json(json& ctx, const Student& instance)
        {
            ctx["mClassID"] = instance.mClassID;
            ctx["mGender"] = instance.mGender;
        }

        static void from_json(const json& ctx, Student& instance)
        {
            instance.mClassID = ctx.at("mClassID").get<int>();
            instance.mGender = ctx.at("mGender").get<bool>();
        }
    };
}

